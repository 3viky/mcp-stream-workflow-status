/**
 * Background worker for processing intelligent summary generation jobs
 *
 * Polls the database for pending jobs and generates summaries incrementally
 */

import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import { execSync } from 'node:child_process';
import { simpleGit } from 'simple-git';
import { getDatabase } from '../database/client.js';
import type Database from 'better-sqlite3';

// Execution lock to prevent concurrent job processing
// Critical: Git operations to main must be sequential to avoid conflicts
let isProcessing = false;

interface SummaryJob {
  id: number;
  stream_id: string;
  stream_number: string;
  stream_title: string;
  stream_category: string;
  stream_branch: string;
  stream_worktree_path: string;
  stream_created_at: string;
  stream_completed_at: string | null;
  user_summary: string;
  history_file_path: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  attempts: number;
  max_attempts: number;
  error_message: string | null;
}

/**
 * Get next pending job from the queue
 */
function getNextJob(db: Database.Database): SummaryJob | null {
  const stmt = db.prepare(`
    SELECT * FROM summary_jobs
    WHERE status = 'pending'
      AND attempts < max_attempts
    ORDER BY created_at ASC
    LIMIT 1
  `);

  return stmt.get() as SummaryJob | null;
}

/**
 * Mark job as processing
 */
function markJobProcessing(db: Database.Database, jobId: number): void {
  const stmt = db.prepare(`
    UPDATE summary_jobs
    SET status = 'processing',
        started_at = datetime('now'),
        attempts = attempts + 1
    WHERE id = ?
  `);

  stmt.run(jobId);
}

/**
 * Mark job as completed
 */
function markJobCompleted(db: Database.Database, jobId: number): void {
  const stmt = db.prepare(`
    UPDATE summary_jobs
    SET status = 'completed',
        completed_at = datetime('now')
    WHERE id = ?
  `);

  stmt.run(jobId);
}

/**
 * Mark job as failed
 */
function markJobFailed(db: Database.Database, jobId: number, error: string): void {
  const stmt = db.prepare(`
    UPDATE summary_jobs
    SET status = CASE
          WHEN attempts >= max_attempts THEN 'failed'
          ELSE 'pending'
        END,
        error_message = ?
    WHERE id = ?
  `);

  stmt.run(error, jobId);
}

/**
 * Generate intelligent summary using Claude
 */
async function generateIntelligentSummary(job: SummaryJob, projectRoot: string): Promise<string> {
  const prompt = `You are analyzing a completed development stream to generate a retirement report.

Stream Details:
- ID: ${job.stream_id}
- Number: ${job.stream_number}
- Title: ${job.stream_title}
- Category: ${job.stream_category}
- Branch: ${job.stream_branch}
- Worktree: ${job.stream_worktree_path}
- Created: ${job.stream_created_at}
- Completed: ${job.stream_completed_at || 'Recently'}

User-provided summary: ${job.user_summary}

Task: Generate a detailed 2-4 paragraph summary of what was accomplished in this stream.
Look at the git commits, changes made, and any documentation.
Focus on:
1. What features/fixes were implemented
2. What problems were solved
3. Technical approach or key decisions
4. Impact on the codebase

Write in past tense, be specific and technical. Do NOT use phrases like "this stream" or "the developer".
Just describe what was done.`;

  const result = execSync(
    `claude -p "${prompt.replace(/"/g, '\\"')}"`,
    {
      encoding: 'utf-8',
      cwd: projectRoot,
      timeout: 60000, // 60 second timeout
      stdio: ['pipe', 'pipe', 'pipe'],
    }
  );

  return result.trim();
}

/**
 * Update history file with intelligent summary and commit to git
 */
async function updateHistoryFile(
  filePath: string,
  oldSummary: string,
  newSummary: string,
  projectRoot: string
): Promise<void> {
  if (!existsSync(filePath)) {
    throw new Error(`History file not found: ${filePath}`);
  }

  const content = readFileSync(filePath, 'utf-8');

  // Replace the placeholder summary with the intelligent summary
  const updatedContent = content.replace(
    `## Summary\n\n${oldSummary}`,
    `## Summary\n\n${newSummary}\n\n---\n\n*Summary generated by Claude on ${new Date().toISOString()}*`
  );

  if (updatedContent === content) {
    throw new Error('Summary replacement failed - old summary not found in file');
  }

  writeFileSync(filePath, updatedContent, 'utf-8');

  // Commit and push the updated file
  const git = simpleGit(projectRoot);
  await git.add(filePath);
  await git.commit(`docs: Update intelligent summary for ${filePath}`, ['--no-verify']);
  await git.push('origin', 'main');

  console.log(`[summary-worker] Updated and pushed ${filePath}`);
}

/**
 * Process a single job
 */
export async function processJob(db: Database.Database, job: SummaryJob, projectRoot: string): Promise<void> {
  console.log(`[summary-worker] Processing job ${job.id} for stream ${job.stream_id}`);

  markJobProcessing(db, job.id);

  try {
    // Generate intelligent summary
    const intelligentSummary = await generateIntelligentSummary(job, projectRoot);

    // Validate response
    if (intelligentSummary.length < 50) {
      throw new Error('Generated summary too short');
    }

    // Update history file and commit to git
    await updateHistoryFile(job.history_file_path, job.user_summary, intelligentSummary, projectRoot);

    // Mark as completed and delete job
    markJobCompleted(db, job.id);

    console.log(`[summary-worker] Completed job ${job.id} for stream ${job.stream_id}`);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`[summary-worker] Job ${job.id} failed:`, errorMessage);

    markJobFailed(db, job.id, errorMessage);

    if (job.attempts + 1 >= job.max_attempts) {
      console.error(`[summary-worker] Job ${job.id} exhausted all retry attempts`);
    }
  }
}

/**
 * Check if current time is within the maintenance window (3am-6am local time)
 */
function isMaintenanceWindow(): boolean {
  const now = new Date();
  const hour = now.getHours();
  return hour >= 3 && hour < 6;
}

/**
 * Process all pending jobs (run once)
 * Only processes jobs during maintenance window (3am-6am)
 *
 * CRITICAL: Uses execution lock to prevent concurrent processing
 * Git operations to main must be sequential to avoid conflicts
 */
export async function processPendingJobs(projectRoot: string): Promise<number> {
  // Check execution lock - skip if already processing
  if (isProcessing) {
    console.log('[summary-worker] Skipping: previous job batch still processing');
    return 0;
  }

  // Acquire lock
  isProcessing = true;

  try {
    const db = getDatabase();
    let processed = 0;

    // Check if we're in the maintenance window
    if (!isMaintenanceWindow()) {
      const now = new Date();
      const hour = now.getHours();
      const nextWindow = hour < 3 ? `in ${3 - hour} hours` : 'tomorrow at 3am';
      console.log(`[summary-worker] Outside maintenance window (3am-6am). Current time: ${now.toLocaleTimeString()}. Next window: ${nextWindow}`);
      return 0;
    }

    while (true) {
      const job = getNextJob(db);
      if (!job) {
        break; // No more jobs
      }

      console.log(`[summary-worker] Processing job ${job.id}/${job.stream_id} (attempt ${job.attempts + 1}/${job.max_attempts})`);
      await processJob(db, job, projectRoot);
      processed++;

      // Small delay between jobs to avoid hammering the API
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    return processed;
  } finally {
    // Always release lock, even if errors occur
    isProcessing = false;
  }
}

/**
 * Worker loop - continuously process jobs
 * Only processes jobs during maintenance window (3am-6am local time)
 */
export async function startWorker(projectRoot: string, pollInterval = 10000): Promise<void> {
  console.log('[summary-worker] Starting background worker...');
  console.log(`[summary-worker] Poll interval: ${pollInterval}ms`);
  console.log('[summary-worker] Maintenance window: 3am-6am local time');

  while (true) {
    try {
      const processed = await processPendingJobs(projectRoot);

      if (processed > 0) {
        console.log(`[summary-worker] Processed ${processed} jobs`);
      }

      // Wait before next poll
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    } catch (error) {
      console.error('[summary-worker] Worker error:', error);
      // Continue running even if there's an error
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
  }
}
